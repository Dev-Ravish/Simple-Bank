
# SIMPLEBANK

### Postgres setup and CRUD implementation
First let's start with makinhg the docker container (using the image postres:12-alpine in our case) by running the command:
```
docker run -p 8800:8800 --name postgres12 -e POSTGRES_USER=root -e POSTGRES_PASSWORD=secret -d postgres:12-alpine
```

Then here we start with making the migrating file first for db creating by:
- Creating directory `db/migration`
- Then run the following command in the terminal `migrate create -ext sql -dir db/migration -seq init_schema`   (TRY TO RUN `migrate --help` to learn more about it)
    - Here you would have go two files `down.sql` (to revert back to prev db state) and `up.sql`(to move to next db state)
- Then we created the Makefile for making custom commands for future usecases in order to work efficiently.

So, once the database is set up, we can start by migrating the tables to the database by using `migrateup` and `,migratedown` written in Makefile.

**Now, It is time for sqlc setup**

For this, we are required to first run the `sqlc init` in order to initialize the sqlc in our module and then make changes in the `sqlc.yaml` file which got generated by taking reference to the github repo taking note of the version.

Then, to run the `sqlc generate` command, we should first create an sql file indside db/query folder for writing at least one query that would be execcuted when the generation is invoked.

```
Do not make any changes to the files that get generated after running the command sqlc generate
```

Next Steps: 
1. For all different schema models start creating new sql files inside query.
2. Take inspiration from the github regarding CRUD operations and then start writing sql queries along with the function name with which you want it to be created (with -- flag).
3. Once, each of the queries for all the files are done run the `sqlc generate` command and you will see new files generated with all the required function in the sqlc folder.


### Testing

1. First of all, we are required to make a main testing folder (`main_test.go` in our case). 2. Then, we are required to establish a connection using `sql.open(driver_name, connection_url)` where the driver_name here is postgres and these drivers are only accessible by the package `github.com/lib/pq` which is imported as a blank import (init() of whose is qutomatically called which defines those named drivers of which postgres is also a part).
3. Then form a testQueries variable of type *Queries and assign it with new(conn), so that we get access of all the functions that are made in the .sql can be accessible using that variable.
4. Next, start building test files for each of the sqlc components/files that is meant for the feature of your application.
